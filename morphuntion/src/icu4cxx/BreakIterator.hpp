/*
 * Copyright 2016-2024 Apple Inc. All rights reserved.
 */
// This is a generated file. Do not edit this file.
#pragma once
#include <string_view>
#include <morphuntion/exception/ICUException.hpp>
#include <morphuntion/exception/NullPointerException.hpp>
#include <unicode/ubrk.h>

namespace icu4cxx {
class BreakIterator {
public:
BreakIterator(UBreakIteratorType type, const char * locale, std::u16string_view text) {
    UErrorCode ec = U_ZERO_ERROR;
    wrappee_ = ubrk_open(type, locale, (const UChar *)text.data(), (int32_t)text.size(), &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
}
BreakIterator(std::u16string_view rules, std::u16string_view text, UParseError * parseErr) {
    UErrorCode ec = U_ZERO_ERROR;
    wrappee_ = ubrk_openRules((const UChar *)rules.data(), (int32_t)rules.size(), (const UChar *)text.data(), (int32_t)text.size(), parseErr, &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
}
BreakIterator(const uint8_t * binaryRules, int32_t rulesLength, std::u16string_view text) {
    UErrorCode ec = U_ZERO_ERROR;
    wrappee_ = ubrk_openBinaryRules(binaryRules, rulesLength, (const UChar *)text.data(), (int32_t)text.size(), &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
}
BreakIterator(const BreakIterator &bi) {
    UErrorCode ec = U_ZERO_ERROR;
    wrappee_ = ubrk_clone(bi.wrappee_, &ec);
    owned_ = true;
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
}
BreakIterator& operator=(const BreakIterator &other) noexcept {
    BreakIterator tmp(other);
    *this = std::move(tmp);
    return *this;
}
~BreakIterator() noexcept {
    if (owned_) ubrk_close(wrappee_);
}
BreakIterator(BreakIterator &&other) noexcept : wrappee_(other.wrappee_), owned_(other.owned_) {
    other.wrappee_ = nullptr;
}
BreakIterator& operator=(BreakIterator &&other) noexcept {
    if (owned_) ubrk_close(wrappee_);
    wrappee_ = other.wrappee_;
    owned_ = other.owned_;
    other.wrappee_ = nullptr;
    other.owned_ = false;
    return *this;
}
void setText(std::u16string_view text) {
    UErrorCode ec = U_ZERO_ERROR;
    ubrk_setText(wrappee_, (const UChar *)text.data(), (int32_t)text.size(), &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
}
void setUText(UText * text) {
    UErrorCode ec = U_ZERO_ERROR;
    ubrk_setUText(wrappee_, text, &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
}
int32_t current() const {
    return ubrk_current(wrappee_);
}
int32_t next() {
    return ubrk_next(wrappee_);
}
int32_t previous() {
    return ubrk_previous(wrappee_);
}
int32_t first() {
    return ubrk_first(wrappee_);
}
int32_t last() {
    return ubrk_last(wrappee_);
}
int32_t preceding(int32_t offset) {
    return ubrk_preceding(wrappee_, offset);
}
int32_t following(int32_t offset) {
    return ubrk_following(wrappee_, offset);
}
static const char * getAvailable(int32_t index) {
    return ubrk_getAvailable(index);
}
static int32_t countAvailable() {
    return ubrk_countAvailable();
}
bool isBoundary(int32_t offset) {
    return ubrk_isBoundary(wrappee_, offset);
}
int32_t getRuleStatus() {
    return ubrk_getRuleStatus(wrappee_);
}
int32_t getRuleStatusVec(int32_t * fillInVec, int32_t capacity) {
    UErrorCode ec = U_ZERO_ERROR;
    auto retVal = ubrk_getRuleStatusVec(wrappee_, fillInVec, capacity, &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
    return retVal;
}
const char * getLocaleByType(ULocDataLocaleType type) const {
    UErrorCode ec = U_ZERO_ERROR;
    auto retVal = ubrk_getLocaleByType(wrappee_, type, &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
    return retVal;
}
void refreshUText(UText * text) {
    UErrorCode ec = U_ZERO_ERROR;
    ubrk_refreshUText(wrappee_, text, &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
}
int32_t getBinaryRules(uint8_t * binaryRules, int32_t rulesCapacity) {
    UErrorCode ec = U_ZERO_ERROR;
    auto retVal = ubrk_getBinaryRules(wrappee_, binaryRules, rulesCapacity, &ec);
    ::morphuntion::exception::ICUException::throwOnFailure(ec);
    return retVal;
}

UBreakIterator *wrappee_ {  };
BreakIterator(const UBreakIterator *other, bool owned = true) : wrappee_((UBreakIterator *)other), owned_(owned) {}
private:
bool owned_ = true;
};
} //namespace icu4xx 
