/*
 * Copyright 2019-2024 Apple Inc. All rights reserved.
 */
//
// Created by Nolan Kramer on 2019-03-28.
//
#include <libxml/tree.h>
#include <libxml/parser.h>

#include <algorithm>
#include <functional>
#include <iostream>
#include <fstream>
#include <sstream>
#include <set>
#include <string>
#include <map>

// xml2cpp -> deserializes an XML into one giant C data structure

// Return the usage string for this tool
std::string get_usage_string() {
    return "Usage: xml2cpp <input file (.xml and .dtd)> <output file (.hpp)>";
}

class XMLCPPGenerator {
private:
    // gets properties for a node
    static std::map<std::string, std::string> nodeProperties(xmlNodePtr node) {
        std::map<std::string, std::string> properties;
        xmlAttr* property = node->properties;

        while (property != nullptr) {
            if (property->children != nullptr && property->children->content != nullptr) {
                properties[std::string(reinterpret_cast<const char *>(property->name))] = std::string(reinterpret_cast<const char *>(property->children->content));
            }
            property = property->next;
        }

        return properties;
    }

    static bool isPropertyNameBoolean(const std::string& value) {
        return value == "aliasable";
    }
    static bool isPropertyBoolean(const std::string& value) {
        return (value == "false" || value == "true");
    }

    // runs function on depth-first during unwind, tracking index of children and generating a declaration string for each node
    // parameters: root pointer, 0, generated name for root pointer, function to run on each node
    static void bottomUpDFRecurse(xmlNodePtr node, size_t childnum, std::string declString, std::function<void(xmlNodePtr, size_t, std::string)> funToRun) {
        if (node->parent->type != XML_DOCUMENT_NODE) {
            std::string name = reinterpret_cast<const char *>(node->name);
            std::transform(name.begin(), name.end(), name.begin(), ::toupper);
            declString += name + std::to_string(childnum);
        }
        xmlNodePtr child = node->xmlChildrenNode;
        std::map<std::string, size_t> childrenCounts;
        while(child != nullptr) {
            if (child->type == XML_ELEMENT_NODE) {
                std::string childname = reinterpret_cast<const char*>(child->name);
                bottomUpDFRecurse(child, childrenCounts[childname], declString + "_", funToRun);
                childrenCounts[childname]++;
            }
            child = child->next;
        }
        funToRun(node, childnum, declString);
    }

public:
    static int convert(const std::string& inFile, const std::string& outFile) {
        auto lastIndex = inFile.find_last_of('.');
        if (lastIndex == std::u16string::npos) {
            std::cerr << "Error: can not find DTD for " << inFile << std::endl;
            return -1;
        }
        std::string inDTDFile = inFile.substr(0, lastIndex) + ".dtd";

        LIBXML_TEST_VERSION

        xmlDocPtr xmlDoc = xmlParseFile(inFile.c_str());
        if (xmlDoc == nullptr) {
            std::cerr << "Error: parsing " << inFile << std::endl;
            return -1;
        }

        xmlDtdPtr dtdDoc = xmlParseDTD((const xmlChar*)("languages"), (const xmlChar*)(inDTDFile.c_str()));
        if (dtdDoc == nullptr) {
            std::cerr << "Error: parsing " << inDTDFile << std::endl;
            return -1;
        }

        xmlNodePtr dtdChild = dtdDoc->children;
        std::map<std::string, std::set<std::string>> elementAttrMap; // maps an element to it's possible attributes
        while(dtdChild != nullptr) {
            if (dtdChild->type == XML_ATTRIBUTE_DECL) {
                xmlAttributePtr attr = (xmlAttributePtr)dtdChild;
                std::string elementName = reinterpret_cast<const char *>(attr->elem);
                elementAttrMap[elementName].insert(reinterpret_cast<const char *>(attr->name));
            }
            dtdChild = dtdChild->next;
        }

        xmlNodePtr root = xmlDocGetRootElement(xmlDoc);
        if (root == nullptr) {
            std::cerr << "Error: root node was null" << std::endl;
            return -1;
        }

        std::stringstream outStringStream;

        outStringStream <<
                        "// Generated by xml2cpp from:" << std::endl << "// " << inFile << ".xml" << std::endl << "// " << inFile << ".dtd" << std::endl <<
                        "#pragma once" << std::endl << std::endl << "#include <stdint.h>" << std::endl << std::endl;

        outStringStream <<
                        "namespace morphuntion::lang::features {" << std::endl <<
                        "struct Value {" << std::endl <<
                        "\tconst char16_t* const gender;" << std::endl <<
                        "\tconst char16_t* const number;" << std::endl <<
                        "\tconst char16_t* const result;" << std::endl <<
                        "\tconst char16_t* const sound;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Feature {" << std::endl <<
                        "\tconst char16_t* const defaultValue;" << std::endl <<
                        "\tconst char16_t* const name;" << std::endl <<
                        "\tint32_t valuesCount;" << std::endl <<
                        "\tconst Value* const value;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Features {" << std::endl <<
                        "\tint32_t featuresCount;" << std::endl <<
                        "\tconst Feature* const feature;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Restriction {" << std::endl <<
                        "\tconst char16_t* const name;" << std::endl <<
                        "\tconst char16_t* const grammeme;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Restrictions {" << std::endl <<
                        "\tint32_t restrictionsCount;" << std::endl <<
                        "\tconst Restriction* const restrictions;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Grammeme {" << std::endl <<
                        "\tconst char16_t* const name;" << std::endl <<
                        "\tconst Restrictions restrictions;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Category {" << std::endl <<
                        "\tconst bool aliasable;" << std::endl <<
                        "\tconst char16_t* const name;" << std::endl <<
                        "\tint32_t grammemeCount;" << std::endl <<
                        "\tconst Grammeme* const grammemes;" << std::endl <<
                        "\tconst Restrictions restrictions;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Grammar {" << std::endl <<
                        "\tint32_t categoryCount;" << std::endl <<
                        "\tconst Category* const category;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Language {" << std::endl <<
                        "\tconst char16_t* const id;" << std::endl <<
                        "\tconst Features features;" << std::endl <<
                        "\tconst Grammar grammar;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Common {" << std::endl <<
                        "\tconst Features features;" << std::endl <<
                        "\tconst Grammar grammar;" << std::endl <<
                        "};" << std::endl << std::endl <<
                        "struct Languages {" << std::endl <<
                        "\tconst Common common;" << std::endl <<
                        "\tint32_t languageCount;" << std::endl <<
                        "\tconst Language* const languages;" << std::endl <<
                        "};" << std::endl << std::endl;

        // this could be deduced from the .dtd but I don't know libxml2 well enough
        std::map<std::string, std::map<std::string, bool>> childMustHaveMultipleChildren;
        childMustHaveMultipleChildren["languages"]["common"] = false;
        childMustHaveMultipleChildren["languages"]["language"] = true;
        childMustHaveMultipleChildren["common"]["features"] = false;
        childMustHaveMultipleChildren["common"]["grammar"] = false;
        childMustHaveMultipleChildren["language"]["features"] = false;
        childMustHaveMultipleChildren["language"]["grammar"] = false;
        childMustHaveMultipleChildren["grammar"]["category"] = true;
        childMustHaveMultipleChildren["category"]["grammeme"] = true;
        childMustHaveMultipleChildren["features"]["feature"] = true;
        childMustHaveMultipleChildren["feature"]["value"] = true;
        childMustHaveMultipleChildren["category"]["restrictions"] = false;
        childMustHaveMultipleChildren["grammeme"]["restrictions"] = false;
        childMustHaveMultipleChildren["restrictions"]["restriction"] = true;

        // parse
        bottomUpDFRecurse(root, 0, "GRAMMAR_XML", [&childMustHaveMultipleChildren, &elementAttrMap, &outStringStream](xmlNodePtr node, size_t /*childNum*/, const std::string& declString) {
            std::string typenameString = reinterpret_cast<const char*>(node->name);
            typenameString[0] = toupper(typenameString[0]);
            std::map<std::string, std::pair<size_t, size_t>> childTypeCount; // maps type -> (occurances, index)
            xmlNodePtr child = node->xmlChildrenNode;
            size_t i = 0;
            while (child != nullptr) {
                if (child->type == XML_ELEMENT_NODE) {
                    std::string nodename = reinterpret_cast<const char*>(child->name);
                    if (childTypeCount.find(nodename) == childTypeCount.end()) {
                        childTypeCount[nodename] = std::pair<size_t, size_t>(1, i);
                        ++i;
                    } else {
                        childTypeCount[nodename].first++;
                    }
                }
                child = child->next;
            }
            // create child arrays
            for (const auto& childTypeCountPair : childTypeCount) {
                if (childMustHaveMultipleChildren[reinterpret_cast<const char*>(node->name)][childTypeCountPair.first]) {
                    std::string childrenTypename = childTypeCountPair.first;
                    std::string childrenDeclname = childrenTypename;
                    std::transform(childrenDeclname.begin(), childrenDeclname.end(), childrenDeclname.begin(),
                                   toupper);
                    childrenTypename[0] = toupper(childrenTypename[0]);
                    outStringStream << "static constexpr " << childrenTypename << ' ' << declString << '_' << childrenDeclname << 'S'
                              << '['
                              << childTypeCountPair.second.first << "] = {" << std::endl;
                    for (size_t j = 0; j < childTypeCountPair.second.first; ++j) {
                        outStringStream << '\t' << declString << '_' << childrenDeclname << j << ',' << std::endl;
                    }
                    outStringStream << "};" << std::endl;
                }
            }

            outStringStream << "static constexpr " << typenameString << " " << declString << " = {";
            // properties
            std::map<std::string, std::string> nodeProps = nodeProperties(node);
            auto attrs = elementAttrMap.find(reinterpret_cast<const char*>(node->name));

            if (attrs != elementAttrMap.end()) {
                for (const std::string& attr : attrs->second) {
                    outStringStream << ' ';
                    auto prop = nodeProps.find(attr);
                    if (prop != nodeProps.end()) {
                        if (isPropertyBoolean(prop->second)) {
                            outStringStream << prop->second;
                        } else {
                            outStringStream << "u\"" << prop->second << '\"';
                        }
                    } else {
                        if (isPropertyNameBoolean(attr)) {
                            outStringStream << "true";
                        } else {
                            outStringStream << "{ }";
                        }
                    }
                    outStringStream << ',';
                }
            }

            i = 0;
            // children
            for (std::pair<std::string, bool> child : childMustHaveMultipleChildren[reinterpret_cast<const char*>(node->name)]) {
                outStringStream << ' ';
                auto typeCount = childTypeCount.find(child.first);
                if (typeCount == childTypeCount.end()) {
                    if (child.second) {
                        outStringStream << "0, { }";
                    }
                    else {
                        outStringStream << "{ }";
                    }
                } else {
                    std::string childrenDeclname = typeCount->first;
                    std::transform(childrenDeclname.begin(), childrenDeclname.end(), childrenDeclname.begin(),
                                   toupper);
                    if (childMustHaveMultipleChildren[reinterpret_cast<const char*>(node->name)][typeCount->first]) {
                        outStringStream << typeCount->second.first << ", ";
                    }
                    outStringStream << declString << '_';
                    if (childMustHaveMultipleChildren[reinterpret_cast<const char*>(node->name)][typeCount->first]) {
                        outStringStream << childrenDeclname << 'S';
                    } else {
                        outStringStream << childrenDeclname << typeCount->second.first - 1;
                    }
                }
                outStringStream << ',';
            }
            outStringStream << " };" << std::endl;
        });

        outStringStream << "}" << std::endl << std::endl;

        std::ofstream out;
        out.open(outFile, std::ios::out | std::ios::trunc);
        out << outStringStream.str();

        xmlFreeDoc(xmlDoc);
        xmlFreeDtd(dtdDoc);
        xmlCleanupParser();

        return 0;
    }
};

int main(int argc, char** argv) {
    // If no command line arguments, print usage and exit
    if (argc < 3) {
        std::cout << get_usage_string() << std::endl;
        return 0;
    }

    return XMLCPPGenerator::convert(argv[1], argv[2]);
}
