/*
 * Copyright 2016-2024 Apple Inc. All rights reserved.
 */
// This is a generated file. Do not edit this file.
#pragma once
#include <string_view>
#include <inflection/exception/ICUException.hpp>
#include <inflection/exception/NullPointerException.hpp>
#include <unicode/uset.h>

namespace icu4cxx {
class UnicodeSet {
public:
UnicodeSet() {
    wrappee_ = uset_openEmpty();
}
UnicodeSet(UChar32 start, UChar32 end) {
    wrappee_ = uset_open(start, end);
}
UnicodeSet(std::u16string_view pattern) {
    UErrorCode ec = U_ZERO_ERROR;
    wrappee_ = uset_openPattern((const UChar *)pattern.data(), (int32_t)pattern.size(), &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
}
UnicodeSet(std::u16string_view pattern, uint32_t options) {
    UErrorCode ec = U_ZERO_ERROR;
    wrappee_ = uset_openPatternOptions((const UChar *)pattern.data(), (int32_t)pattern.size(), options, &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
}
~UnicodeSet() noexcept {
    if (owned_) uset_close(wrappee_);
}
UnicodeSet(UnicodeSet &&other) noexcept : wrappee_(other.wrappee_), owned_(other.owned_) {
    other.wrappee_ = nullptr;
}
UnicodeSet& operator=(UnicodeSet &&other) noexcept {
    if (owned_) uset_close(wrappee_);
    wrappee_ = other.wrappee_;
    owned_ = other.owned_;
    other.wrappee_ = nullptr;
    other.owned_ = false;
    return *this;
}
UnicodeSet(const UnicodeSet &set) {
    wrappee_ = uset_clone(set.wrappee_);
    owned_ = true;
}
UnicodeSet& operator=(const UnicodeSet &other) noexcept {
    UnicodeSet tmp(other);
    *this = std::move(tmp);
    return *this;
}
bool isFrozen() const {
    return uset_isFrozen(wrappee_);
}
void freeze() {
    uset_freeze(wrappee_);
}
UnicodeSet cloneAsThawed() const {
    return uset_cloneAsThawed(wrappee_);
}
void set(UChar32 start, UChar32 end) {
    uset_set(wrappee_, start, end);
}
int32_t applyPattern(std::u16string_view pattern, uint32_t options) {
    UErrorCode ec = U_ZERO_ERROR;
    auto retVal = uset_applyPattern(wrappee_, (const UChar *)pattern.data(), (int32_t)pattern.size(), options, &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
    return retVal;
}
void applyIntPropertyValue(UProperty prop, int32_t value) {
    UErrorCode ec = U_ZERO_ERROR;
    uset_applyIntPropertyValue(wrappee_, prop, value, &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
}
void applyPropertyAlias(std::u16string_view prop, std::u16string_view value) {
    UErrorCode ec = U_ZERO_ERROR;
    uset_applyPropertyAlias(wrappee_, (const UChar *)prop.data(), (int32_t)prop.size(), (const UChar *)value.data(), (int32_t)value.size(), &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
}
static bool resemblesPattern(std::u16string_view pattern, int32_t pos) {
    return uset_resemblesPattern((const UChar *)pattern.data(), (int32_t)pattern.size(), pos);
}
int32_t toPattern(UChar * result, int32_t resultCapacity, bool escapeUnprintable) const {
    UErrorCode ec = U_ZERO_ERROR;
    auto retVal = uset_toPattern(wrappee_, result, resultCapacity, escapeUnprintable, &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
    return retVal;
}
void add(UChar32 c) {
    uset_add(wrappee_, c);
}
void addAll(const UnicodeSet & additionalSet) {
    uset_addAll(wrappee_, additionalSet.wrappee_);
}
void addRange(UChar32 start, UChar32 end) {
    uset_addRange(wrappee_, start, end);
}
void addString(std::u16string_view str) {
    uset_addString(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void addAllCodePoints(std::u16string_view str) {
    uset_addAllCodePoints(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void remove(UChar32 c) {
    uset_remove(wrappee_, c);
}
void removeRange(UChar32 start, UChar32 end) {
    uset_removeRange(wrappee_, start, end);
}
void removeString(std::u16string_view str) {
    uset_removeString(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void removeAllCodePoints(std::u16string_view str) {
    uset_removeAllCodePoints(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void removeAll(const UnicodeSet & removeSet) {
    uset_removeAll(wrappee_, removeSet.wrappee_);
}
void retain(UChar32 start, UChar32 end) {
    uset_retain(wrappee_, start, end);
}
void retainString(std::u16string_view str) {
    uset_retainString(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void retainAllCodePoints(std::u16string_view str) {
    uset_retainAllCodePoints(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void retainAll(const UnicodeSet & retain) {
    uset_retainAll(wrappee_, retain.wrappee_);
}
void compact() {
    uset_compact(wrappee_);
}
void complement() {
    uset_complement(wrappee_);
}
void complementRange(UChar32 start, UChar32 end) {
    uset_complementRange(wrappee_, start, end);
}
void complementString(std::u16string_view str) {
    uset_complementString(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void complementAllCodePoints(std::u16string_view str) {
    uset_complementAllCodePoints(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
void complementAll(const UnicodeSet & complement) {
    uset_complementAll(wrappee_, complement.wrappee_);
}
void clear() {
    uset_clear(wrappee_);
}
void closeOver(int32_t attributes) {
    uset_closeOver(wrappee_, attributes);
}
void removeAllStrings() {
    uset_removeAllStrings(wrappee_);
}
bool isEmpty() const {
    return uset_isEmpty(wrappee_);
}
bool hasStrings() const {
    return uset_hasStrings(wrappee_);
}
bool contains(UChar32 c) const {
    return uset_contains(wrappee_, c);
}
bool containsRange(UChar32 start, UChar32 end) const {
    return uset_containsRange(wrappee_, start, end);
}
bool containsString(std::u16string_view str) const {
    return uset_containsString(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
int32_t indexOf(UChar32 c) const {
    return uset_indexOf(wrappee_, c);
}
UChar32 charAt(int32_t charIndex) const {
    return uset_charAt(wrappee_, charIndex);
}
int32_t size() const {
    return uset_size(wrappee_);
}
int32_t getRangeCount() const {
    return uset_getRangeCount(wrappee_);
}
int32_t getItemCount() const {
    return uset_getItemCount(wrappee_);
}
int32_t getItem(int32_t itemIndex, UChar32 * start, UChar32 * end, UChar * str, int32_t strCapacity) const {
    UErrorCode ec = U_ZERO_ERROR;
    auto retVal = uset_getItem(wrappee_, itemIndex, start, end, str, strCapacity, &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
    return retVal;
}
bool containsAll(const UnicodeSet & set2) const {
    return uset_containsAll(wrappee_, set2.wrappee_);
}
bool containsAllCodePoints(std::u16string_view str) const {
    return uset_containsAllCodePoints(wrappee_, (const UChar *)str.data(), (int32_t)str.size());
}
bool containsNone(const UnicodeSet & set2) const {
    return uset_containsNone(wrappee_, set2.wrappee_);
}
bool containsSome(const UnicodeSet & set2) const {
    return uset_containsSome(wrappee_, set2.wrappee_);
}
int32_t span(std::u16string_view s, USetSpanCondition spanCondition) const {
    return uset_span(wrappee_, (const UChar *)s.data(), (int32_t)s.size(), spanCondition);
}
int32_t spanBack(std::u16string_view s, USetSpanCondition spanCondition) const {
    return uset_spanBack(wrappee_, (const UChar *)s.data(), (int32_t)s.size(), spanCondition);
}
int32_t spanUTF8(std::string_view s, USetSpanCondition spanCondition) const {
    return uset_spanUTF8(wrappee_, (const char *)s.data(), (int32_t)s.size(), spanCondition);
}
int32_t spanBackUTF8(std::string_view s, USetSpanCondition spanCondition) const {
    return uset_spanBackUTF8(wrappee_, (const char *)s.data(), (int32_t)s.size(), spanCondition);
}
bool equals(const UnicodeSet & set2) const {
    return uset_equals(wrappee_, set2.wrappee_);
}
int32_t serialize(uint16_t * dest, int32_t destCapacity) const {
    UErrorCode ec = U_ZERO_ERROR;
    auto retVal = uset_serialize(wrappee_, dest, destCapacity, &ec);
    ::inflection::exception::ICUException::throwOnFailure(ec);
    return retVal;
}

USet *wrappee_ {  };
UnicodeSet(const USet *other, bool owned = true) : wrappee_((USet *)other), owned_(owned) {}
private:
bool owned_ = true;
};
} //namespace icu4xx 
